local newTileLayer = require("tilelayer")
local im = require("InputManager")
local camera = require("camera")
local vec2 = require("brinevector")
local bump = require("bump")
local flux = require("flux")
-- alias para comodidad
local lg = love.graphics

-- table de alamacenaje para conveniencia. se almacena estado dentro
local my = {}

function love.load()
    -- crear TileLayers
    math.randomseed(os.time())
    my.backlayer = newTileLayer(40, 30, 40)
    my.frontlayer = newTileLayer(50, 10, 40, 40, {1,1,0,0.3})

    -- funcion de dibujado para pasar al creador de nodos
    -- hace un cuadrado magenta del tamano del tile
    local function drawMagenta(self)
        lg.setColor(1,0,1,1)
        lg.rectangle("fill", self.x, self.y, self.parent.w, self.parent.h)
    end

    -- creo un grid en el backlayer
    for i = 0, 40 do
        for j = 0, 40 do
            my.backlayer:newTile(i, j)
        end
    end

    -- creo objetos random en el frontlayer
    for _ = 0, 50 do
        local x,y
        repeat
            x,y = math.random(0,30), math.random(0,30)
        until my.frontlayer:checkFree(x, y)
        my.frontlayer:newTile(x, y, drawMagenta)
    end

    my.player = {
        pos = vec2(300,300),
        size = vec2 (32,32),
        center = vec2(316, 316),
        parent = my.frontlayer,
        draw = function(self)
            lg.setColor(1,1,0,1)
            lg.rectangle("fill", self.pos.x, self.pos.y, self.size.x, self.size.y)
        end,
        move = function(self, mov)
            self.pos = self.pos + mov
            self.center = self.center + mov
        end,
    }

    table.insert(my.frontlayer.tiles, my.player)
    my.cam = camera(300,300)

    -- preparo table de los inputs que usa el juego ( tecla = nombre_de_input )
    local bindings = {
        escape = 'escape',
        w = 'up',
        a = 'left',
        s = 'down',
        d = 'right',
        u = 'scale down',
        i = 'scale up',
        j = 'action',
        k = 'cancel',
    }
    im.registerBindings(bindings)
end

function love.update(dt)
    flux.update(dt)

    local speed = 200

    local inputs = {}
    while im.pollInputs(inputs) do
        if inputs.code == 'escape' then love.event.quit()
        end
    end

    local mov = vec2()
    if im.isCodeDown('up') then     mov.y = -1 end
    if im.isCodeDown('down') then   mov.y = 1 end
    if im.isCodeDown('left') then   mov.x = -1 end
    if im.isCodeDown('right') then  mov.x = 1 end
    if im.isCodeDown('scale up') then my.cam.scale = my.cam.scale + math.log10(my.cam.scale * 10) * dt end
    if im.isCodeDown('scale down') then if my.cam.scale > 1 then my.cam.scale = my.cam.scale - math.log10(my.cam.scale * 10) * dt end end

    mov = mov.normalized * speed * dt
    my.player:move(mov)

    my.frontlayer:update()
    my.cam:lockPosition(my.player.center.x, my.player.center.y, camera.smooth.damped(8))
end

function love.draw()
    my.cam:attach()
        my.backlayer:draw()
        my.frontlayer:draw()
    my.cam:detach()
end
